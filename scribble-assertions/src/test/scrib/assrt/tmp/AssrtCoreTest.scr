//Raymond@HZHL3 ~/code/eclipse/scribble/github.com/rhu1-assrt/scribble-java
//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtCoreTest.scr -fair -z3 -assrt Proto1 -modelpng Proto1 Proto1.png -fsmpng Proto1 A Proto1_A.png -fsmpng Proto1 B Proto1_B.png


// http://sandbox.kidstrythisathome.com/erdos/




// FIXME: debug printing for assertion passes

// FIXME: distinguish branches where "not guaranteed safe" vs "impossible"



// unary choice: 
//   pre: forall (lhs)
//   forall lhs => (exists rhs) -- point is rhs may use vars in lhs
//   exists (lhs /\ rhs)
// -- forall [ (lhs /\ (lhs => (exists rhs))) => exists (lhs /\ rhs) ] -- ?
// -- forall [ lhs /\ (lhs => (exists rhs))) ] => forall [ exists (lhs /\ rhs) ] -- ?
/*
(declare-fun lhs (Int Int) Bool)
(declare-fun rhs (Int Int Int Int) Bool)
(assert (forall ((x1 Int) (y1 Int)) (lhs x1 y1)))
(assert  (=>   
  (forall ((x1 Int) (y1 Int)) (and (lhs x1 y1) (=> (lhs x1 y1) (exists ((x2 Int) (y2 Int)) (rhs x1 y1 x2 y2)))))
  (forall ((x1 Int) (y1 Int)) (exists ((x2 Int) (y2 Int)) (and (lhs x1 y1) (rhs x1 y1 x2 y2))))
))
(check-sat)  // FIXME: check negation is unsat
(exit)  
*/


// FIXME: statevar decl invariants
// muZ for fixed points -- recursive statevar updates? -- http://rise4fun.com/Z3/tutorial/fixedpoints

// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

// .. checking assertions sender side only is important for services -- maybe complex/expensive operation, point is to ask service to do it, so must be the service only to check it also

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?

// FIXME: batching optimisation contains redundancy? -- all formulae are standalone (full "trace histories"), but maybe not necessary if batching?




// unsat is a preserving safety error, op sem should freeze on an unsat choice -- but otherwise should allow branch selection, even if not "strictly" assert-prog
// assert-prog is a progress guarantee, but not a preserving safety error -- because assert-prog says there isn't a guaranteed option to proceed, but by op sem we can take any non-unsat case anyway

// try: simply compact all clauses with old vars -- since old var value is "lost", can never eval the clause anyway? -- model corresponds to the way syntactic var substitution works?
//		more explicitly, it corresponds to a scoping mechanism derived from syntactic source protocol that determines what vars can be "used" as constraints at protocol points?
// or continue-specific ("statevar update" of action) GC of clauses with old vars?

// F is a set of constraints that are true so far, but need to record to check more upcoming constraints
// once any clause has an "old var", can delete the clause because model is that we don't have old var value anymore so can't evaluate the constraint
// arguing about the "value" doesn't really make sense here, because doing forall anyway
// it's more like, "old var" ever won't be "used" in an upcoming constraint -- at least not "directly", but also not "indirectly"? -- also not "indrectly" because of "temporal ordering" given by syntax: e.g., x->y->z->loop, if x becomes old, then any upcoming use of y must also occur after y becomes old




// merging DONE
// - coreconfig flags Map->Set -- done: refactored separate CoreArgs and CoreFlags
// - make uniform orig/new assrt node parsing/astfactor (refactor parser mixed new ast types with old token types) -- refactor new ast types to fully subsume old ones (e.g., getChildren) -- done
// - fix new parser reflection in tree adaptor (no common interface for "module" top-level method) -- done
// - refactor astfactoryimpl token constants to parser (and refactor ast/delfactoryimpl to scribble-ast) -- done: ScribAntlrTokens

// merging TODO
// - CHECKME: GTypeTranslation syntax exception (JUnit harness)
// - rename "new" factory methods? (easily confused with new expr)  centralise?
// - rename AssrtCore to Core? -- implement "strict" mode via translator?
	// - proto params not supported -- CHECKME: mixing rec/continue with protodecl/do
// - refactor exceptions to main packages
// - refactor -inline via temporary directory/file
// - check super.addScribChildren pattern
// - consider del's over ast subclassing for ext's like assrt -- alternatively, extend base's, and subclass for G/L (instead of extending G/L)
// - check genereal overrides, return super types where better -- @deprecate runtimeexception overrides? e.g, reconstruct
// - check Assrt NameDisamb/checkAnnot passes
// - rename Assertions.g related stuff with Annot prefix
// - disamb annot statevars (etc?) to qualified names, avoid "rename" issues (cf. AssrtCoreSConfig)
// - maybe move init config factory from util to builder?
// - refactor model (safety) error checking operations into EFsm? (need to pass queues) 
// - refactor common formula building for error checks in AssrtCoreSConfig

// later:
// - fix duplicate proto decl name check
// - refactor modulecontext building, move dup vis name checks out (drop scribexception)
// - try var type inference
// - refactor namedisamb functionality
// - annot var lin modifier?  etc?
// - consider refactoring Core/Config/Context to be more neutral of G/LProtocol (use Protocol super)
//		- consider refactoring base as an ext outside of core
//		- separate core (seq) from "classic"? -- maybe add Seq as an "ext" of classic? (currently deprecating a lot of core for classic, but should be the other way round)
//		- consider replacing some inheritance by nesting, e.g., LProjection/Protocol (cf. SModel/SGraph)
// - refactor Kinds as types only?  or values needed for serialization?
// - fix UnaryPayElem generic casts (and AssrtAnnotDataElem)
// - standardise EFSM/model format -- should contain data type info (e.g., for STP) -- should make a decl language for FSM module members, share imports with protos





/*
- model checking: uniform validation for integrating different MPST features
- assertions only "reduce" behaviours? true-only assertions
- basic model based on "types" -- so 1-bounded finite
- how to introduce semantics of assertions into model and stay finite?
-- because assertions introduce values -- arithmetic
- have to leverage syntactic characteristics to support the model checking
-- all about recursion (including action assertions, not only statevars), managing finiteness
-- assertions as syntactic terms (syntactically equal terms have same meaning), CNF sets allows "syntactic"-closure on constraints -- no hardcoded two-unfolding
-- "old actvar" renaming for recursively "shadowed" vars -- following syntactic recursion substitution -- cf. fresh vars
--- multiparty old actvar renaming based on message flow
--- then compacting -- i.e., syntactic term GC hack
-- then the "inductive" step, given by old statvar renaming becoming forall
--- very conserative -- restore "precision" by recursion assertions as "loop invariants"
- so model checked errors: unknownvar (HS), assert-prog (TS?), sat (TS?), recursion-assert
*/

module assrt.tmp.AssrtCoreTest;


type <dotnet> "System.UInt32" from "..." as int;
//type <dotnet> "System.String" from "..." as str;




/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 1"
}
//*/


/*
// CHECKME: val forwarding, w.r.t. local K+F's
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;  @"x > 1"
	1(y: int) from B to C;  @"x = y"
}
//*/
















/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;
	2(y: int) from A to C;
	do Proto1(A, B, C);  // Testing updateScopes, records *past* scopes (i.e., excluding current) in order
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	0() from A to B;
	do Loop(A, B, C);
}

aux global protocol Loop(role A, role B, role C)
{
	IsAbove(v1:int) from A to B;  
	SecOut(r2:int) from A to C;  
			// Testing updateScopes model construction -- v1 can be dropped and re-sent before first r2 is picked (async recursion) -- increases state space
			// Tests updateScopes, non-initial self-recursion
	do Loop(A, B, C);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from A to B;
	do Loop(A, B, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;   
		Res(b1:int) from R to P;
		IsAbove(v2:int) from P to R;   
		Res(b2:int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;  // Testing tarjan -- updateScopes explodes state space, three-party-interleaves async recursion with K/F-GC
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"  // Testing updateScopes
	2(y: int) from A to B;  @"y>x"
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"  // Testing updateScopes (always empty scopes)
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B) @"x>0"  // FIXME: unknown x -- also tested empty lhs for getRecAssertCheck
{
	1() from A to B;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  // FIXME: do-sexpr WF -- CHECKME: or allow? (cf., below)
	//do Proto1Aux(A, B);  @<"1">
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1"> "x>0"  // Testing getRecAssertCheck lhs building
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	do Proto1(A, B);  @<"2">  // Testing svar initial and update values
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  @<"2">  // Testing "inlining" of do-sexpr args as rec-svar exprs by proto inlining
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1"> "x>0"
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  @<"2">  // FIXME: no target satate var
}

aux global protocol Proto1Aux(role A, role B)  //@"x>0"
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  // TODO CHECKME: allow? (omitted state args)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(y:int) from A to B;  @"y>1"  // TODO: testing F var renaming/compacting -- A async returns to rec-state while B still in "prev" iteration
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1(y:int) from A to B;  @"y>1"
	do Proto1(A, B);  @<"y">  // TODO: testing F var renaming/compacting and V/R renaming
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	2() from B to A;
	do Proto1(A, B);  @<"2">  // HERE FIXME
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;  // Testing removal of _dum1 : _Unit translation for empty payload -- reduces model size
	do Proto1(A, B);  @<"2">  // HERE FIXME
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;  // Testing removal of _dum1 : _Unit translation for empty payload -- reduces model size
	do Proto1(A, B);  @<"1">  // Testing .toTrueAssertion state exprs
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	// FIXME: unused role decls

	do Proto1(A, B);  @<"1">  // (But tested .toTrueAssertion state exprs)
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;	
	do Proto1(A, B);  // CHECKME: OK?
}
//*/






















/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: AssrtCoreTest.int) from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 0"  // Testing whitespace
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"x > 0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"False"  // Testing assrt-prog
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;  @"False"  // Testing assrt-unsat
	}
	or
	{
		2() from A to B;  @"True"
	}
}
//*/


/*
global protocol Proto1(role A, role B)  @"True"
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "1"> "True"
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "1">
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1(A, B);  // Testing base recursive do, inlining
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // Testing base f/w entry do, inlining
}

aux global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // Testing base f/w entry do with recursive do, inlining
}

aux global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  @<"0">  // TODO CHECKME: OK to f/w entry "override" default sexprs?  (depends if default sexprs are for "init" only or not)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	1() from A to B;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // TODO CHECKME: conversely, OK to not supply sexprs?  (o/w rec statevar decl exprs only for root?)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	1() from A to B;	
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "0">
{
	do Proto1(A, B);  @<"1">  // FIXME: A, B, not used
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "0">
{
	1() from A to B;
	do Proto1(A, B);  @<"1">
}
//*/



















/*
global protocol Proto1(role C, role S)
{
	HELLO(u:int) from C to S;
	choice at C
	{
		ADD(w:int) from C to S; 
		ADD(v:int) from C to S; 
		RES(f:int) from S to C;
		do Proto1(C, S);
	}
	or
	{
		BYE() from C to S;
		BYE() from S to C;
	}
}
//*/


/*
global protocol Proto1(role C, role S)
{
	HELLO(int) from C to S;
	choice at C
	{
		ADD(w:int) from C to S;  @"w > 0"
		ADD(v:int) from C to S;  @"v > 0"
		RES(f:int) from S to C;  @"f > 0"
		do Proto1(C, S);
	}
	or
	{
		BYE() from C to S;
		BYE() from S to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(int, int, int, int) from P to R;  // Currently same state space as below, due to "_dum" var names (and K/scopes)
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(int) from P to R;   
		Res(int) from R to P;
		IsAbove(int) from P to R;   
		Res(int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(int, int) from P to R;
			Res(int) from R to P;
			choice at P
			{
				SecOut(int) from P to C;
				do Loop(P, R, C);
			}
			or
			{
				SecIn(int, int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;   
		Res(b1:int) from R to P;
		IsAbove(v2:int) from P to R;   
		Res(b2:int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;  // unfoldScopes state space increase (async recursion with scopes resetting)
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;   
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		IsAbove(v2:int) from P to R;   
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P
		{
			BothIn() from P to R;  @"b1=1 && b2=1"
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;  @"b1=0 && b2=0"
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)" // && y1=v1 && y2=v2
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;  @"b2=0" // && r2=i
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;  @"b2=1" //  && (r3=i && r4=v2)
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


//*
global protocol Proto1(role C, role S)  @<x := "0", y := "1"> "y>0 && x>=0"
		//@"(x := 0, y := 1) y>0 && x>0"  // Bad initial Rass (and later unsat)
		//@"(x := 0, y := 1) (y>0))"
{
	choice at C
	{
		Val(x1:int) from C to S;  @"x1 = x"
		Add(y1:int) from C to S;  @"y1 = y"
		Sum(z:int) from S to C;   @"z = (x1+y1)"
		do Proto1(C, S);          @<"y1", "z">
	}
	or
	{
		Bye() from C to S;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	NumberOne (x: int) from A to B;  //@"x > 3"
	NumberTwo (y: int) from B to C; @ "x = y"
	ReturnValueTwo (z: int) from C to B; @ "z = y + y"
	ReturnValueOne (t: int) from B to A; @ "t = z"
			// Testing what does A know about t -- A knows t=z, but not z = y+y   // CHECKME: OK for A to know "t" (K+F)?  should be sound
			// In general y could be from anywhere, and A won't know y's value
			// However, in this case y = x and x came from A -- CHECKME: refine?  or perhaps if z = x + x
}
//*/















































/*
global protocol Proto1(role A, role B)
{
	//1(x:int) from A to B;  @"x>1 || (x>2 && x>3)"  // Testing CNF

	//1(x:int) from A to B;  @"(x>1 && x>2) || x>3"
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//2(y:int) from A to B;  @"y=x+x && x=x"  // FIXME: combine multiple exprs into sigma conjunction
	2(y:int) from A to B;  @"y=x+x"
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B;  @"x>3"
	choice at A
	{
		2(int) from A to B;  @"x>5"

		//3(int) from A to C;  @"x>6"  // Bad  // TODO add as unit test
		3(int) from A to C;  @"x>4"  // OK
	}
	or
	{
		4(int) from A to B;
		5(int) from A to C;
	}
}
//*/



/*
global protocol P1(role A, role B, role C)
{
	1(x:int) from A to C;
	2(y:int) from B to C;  @"y>x"

	//2(y:int) from C to B;  @"y>x"  // FIXME: paper definition
}

global protocol P2(role A, role B)
{
	1(x:int) from A to B;  @"x>3"
	choice at B
	{
		2() from B to A;
	}
	or
	{
		3(y:int) from B to A; @"((y > (x + 1)) && y < 4)"
	}
}

global protocol P3(role A, role B, role C)
{
	1(x : int) from A to B; @"x > 3"
	2(y : int) from C to B; //@"(y<3 || y=3)"//"!(y=3)"//@"True"
	choice at B
	{
		3() from B to A; @"x < y"
	}
	or
	{
		4() from B to A; @"x > y"
	}
}
//*/



/*
global protocol Proto1(role A, role B, role C)
{
	/*1(x : int) from A to B; @"x > 3"
	choice at B
	{
		2() from B to A; @"True"
	}
	or
	{
		3(y : int) from B to A; @"((y > (x + 1)) && y < 4)"
	}*/
	
	/*1(x : int) from A to B; @"x > 3"
	2(y : int) from C to B; @"True"
	choice at B
	{
		3() from B to A; @"x < y"
	}
	or
	{
		4() from B to A; @"y > x"
	}* /
	
	1(x:int) from A to B;  @"x>3"
	2(y:int) from A to C;  @"y>x"




	/*0(z:int) from B to A;   @"(z>3)"
	choice at A
	{
		1(x:int) from A to B;   @"(x>3)"
	}
	or
	{
		2(y:int) from A to B;   @"(y>3)"
	}*/
		
	
	
	
	/*choice at B
	{
		2(y:int) from B to A;   @"y=x && y>3"
	}
	or
	{
		3(z:int) from B to A;   @"z=x && z<3"
	}* /
}
//*/


/*
assert f(x:int) bool = "x";  
		// Cannot be recursive as an assertion -- so not so useful for "explicit" code gen?  (vs. basic expr capturing) -- mainly use as "assertion code gen"?
		// Should only be for validation?

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//2(y:int) from B to A;  @"y = f(x)"
	2(y:int) from B to A;
}
*/


/*
global protocol Proto1(role A, role B, role C) {
	choice at A
	{
		1() from A to B; @"A1"
		1() from A to C;           // CHECKME: receiver-side ass not projected -- but if it were, would need A1
	}
	or
	{
		...
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

global protocol Loop(role P, role R, role C) {
	choice at P {
		Above(v1:int) from P to R;   
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		Above(v2:int) from P to R;   
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P {
				BothIn() from P to R;  @"b1=1 && b2=1"
				BothIn(r1:int) from P to C;
				do Loop(P, R, C);  // Recursion
			} or {
				BothOut() from P to R;  @"b1=0 && b2=0"
				BothOut() from P to C;
				do Loop(P, R, C);  // Recursion
		} or {
			Intersect() from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)"
			Res(i:int) from R to P;
			choice at P {
				One(r2:int) from P to C;   @"b2=0 && r2=i"
				do Loop(P, R, C);  // Recursion
			} or {
				Two(r3:int, r4:int) from P to C;  @"b2=1 && (r3=i && r4=v2)"
				do Loop(P, R, C);  // Recursion
		} }
	} or {
		Close() from P to R;   
		Close() from P to C;  // End
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	rec Loop {
		choice at P {
			check(p1:int, p2:int) from P to R;
			PointsToForward(res:int) from R to P; @"res>=0 && res<=2"
			choice at R {
				noIntersection() from R to P; @"res=1"
				OnePoint(v1:int) from P to C; @"v1=p2"
				continue Loop;
			} or {
				noPoints() from R to P; @"res=0"
				noPoints() from P to C;
				continue Loop; 
			} or {
				intersection(p3:int) from R to P; @"res=1 || res=2"
				choice at P {
					OnePointb(v2:int) from P to C; @"res=1 && v2=p3"
					continue Loop;
				} or {
					TwoPoint(v3:int, v4:int) from P to C; @"res=2 && (v3=p3 && v4=p2)"
					continue Loop;
				}
			}
		} or {
			Close() from P to R;
			Close() from P to C;
		}
	}
}
//*/



/*
global protocol Proto1(role A, role B)
{
	//1(x:int, y:int) from A to B;  @"x>3 && y>4"  // OK

	/*1(x:int, y:int) from A to B;  @"x=y"  // OK
	2() from B to A;  @"x=y"* /

	1(x:int, y:int) from A to B;
	2() from B to A;  @"x=y"  // Bad
}
//*/












/*
..demo:
- model building: model state extensions for assertions
-- assert-prog vs. sat -- DbC assert-prog choice case disjunction
-- bounded model with recursion (1): actvar renaming ("oldvar" GC) -- leveraging syntactic unfolding "semantics" of recursion
-- async MP: renaming following message flows
- statevars
-- bounded model with recursion (2): conservative forall on old statevars
-- "same var" special case
-- statevar invariants -- statevar-assert-prog
- uninterpreted funs
-- domain-specific theories (e.g., open/port)
-- encode roles/etc as ints
-- domain-specific API gen

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"x>3"
	
	choice at B
	{
		2() from B to A;  @"x<0"
		4() from B to A;  @"False"
	}	
	or
	{
		3() from B to A;  @"True"
	}	
}
//*/


























/*
global protocol Proto1a(role A, role B)  @"(x:=1)"
{
	1(x:int) from A to B;	
	2(y:int) from B to A;	 @"y>x"

	do Proto1a(A, B);  @"<x+1>"
}

global protocol Proto1b(role A, role B)
{
	1() from A to B;	
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1c(role A, role B)
{
	1() from A to B;	     @"x>3"
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1d(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"  // y>x added to F(C), but x *not* added to F(C) -- N.B. x will be forall quantified at C, and x>3 *not* in F(C) 
	3(z:int) from C to A;	 @"z>x"
}

global protocol Proto1e(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"
	3(z:int) from A to C;	 @"z>x"  // assertion not checked on receiver side
}

global protocol Proto1f(role A, role B, role C, role D)
{
	1(x1:int) from A to B;	@"x1=3"
	2(x2:int) from A to D;	@"x2=x1"

	3(y1:int) from B to C;	@"y1=x1"
	4(y2:int) from D to C;	@"y2=x2"
	
	5(z:int) from C to A;   @"z=y1 && z=y2"  // only adding "immediate" assertion to F is weak? can strengthen?
}
//*/












/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"!(x<3)"
	2() from A to B;  @"(True && !(False))"

}
//*/

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B) @"2<3"  // FIXME: unknown vars check
{
	2() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B) @"(x:=(1+(1-1)), y:=4)"
{
	1() from A to B; @ "(x<3 && x<3) || x<3+(1+2)"
	//@"(((x>1) && (x>2)) && (x>3))"
	//@"(((True)))"
	2() from B to A; @"foo()"  // FIXME: constants
	//2() from B to A; @"((((True))))"
	do Proto1(A, B);  @"<0, 0>"
}
//*/



// TODO try: mu X . ( A->B 1 . X + A->B 2 . mu Y . A->B 3 . Y ) with statevars and assertions

/*
global protocol Proto1(role A, role B)
		@"(x := 1) (x>0)"
		//@"(x := 0) (x>0)"
{
	//1(y:int) from A to B; @"(y>1)"
	1() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	//1(y:int) from A to B; @"(y>1)"
	1(y:int) from A to B; @"(y>3)"
	do Proto2(A, B); @"(y)"
}

aux global protocol Proto2(role A, role B) @"(x := 0) (x>2)"
{
	2() from B to A;
}
//*/

/*
global protocol Proto1(role A, role B)  @"(x := 1)"
{
	1(y:int) from A to B;  @"(y > x)"
	2() from B to A;
	do Proto1(A, B);  @"(x)"
}
//*/

/*
global protocol Proto1(role A, role B)  
		@"(x := 3) (x>2)"
		//@"(x := 3) (x>0)"
		//@"(x := 3) (x>1)"
{
	1() from A to B; @"(x>1)"
	//2() from B to A;
	//do Proto1(A, B);  @"(x)"  
			// CHECKME: no longer needs to be special case, given appropriate rec-assertion? -- but at least is an optimisation?
			// no: special case still different, no "old var" renaming (no "inductive unrolling")
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

/*
//global protocol Proto1(role A, role B)  @"(x := 1)"
global protocol Proto1(role A, role B)  @"(x := 2) (x>1)"
//global protocol Proto1(role A, role B)  @"(x := 1) (y>0)"
{
	//1() from A to B;
	//1() from A to B; @"(x>0)"
	1() from A to B; @"(x>1)"
	2() from B to A;

	//do Proto1(A, B);  @"(x)"
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

















// uninterpreted functions for custom API gen
// multi statvars -- fibo, linear
/*
global protocol Proto1(role A, role B) @"(x:=(0+3), y:=1)"
{
	1(z:int) from A to B;  @"(x>1)"
	do Proto1(A, B); @"(3, 1)"
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1(lin x:int) from A to B; @port(x, C);  // implies port(x, C) and not(port(x, A)), not(port(x, B))
	
	rec X1 (used_x = 0) {

		1(z:int) from B to C; @(fw(x -> z) ... used_x =0); // implies port(x, C) and not(port(x, A)), not(port(x, B))
		
		rec X2 (used_x = 1) {

			1(z2:int) from B to C; @(... used_x = 0); // implies port(x, C) and not(port(x, A)), not(port(x, B))

			connect B to C;
			2(y:int) from B to A; @(x=y);

			connect C to A; @request(x, C);  // C should know x; should imply port(x, C);
		}
		}
} // terminal state needs all linear used
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; 
	2(y:int) from B to A; @(x=y);
	3(z:int) from B to A; @(z=y);  // Should this be "linearity" error?
}
//*/


























/*/
global protocol Proto1(role A, role B) @(x=0);
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2() from B to A; @(x<1);  // FIXME: shouldn't be in scope without decl as Proto2 statevar -- OK because aux? error caught if Proto2 checked as root
}
//*/

/*
global protocol Proto1(role B, role S)
{
	ok() from B to S;
	do Proto2(B, S); @Quote;  // FIXME: unknown vars check
}

global protocol Proto2(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);  // FIXME: unknown vars check here too?
}
//*/


/*
global protocol Proto1(role A, role B) @(z=3);
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	do Proto1(A, B);  // FIXME: statevar arg check
}
//*/












/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	
	do Proto2(A, B); @(x);  
			// FIXME: need to make expr vars old in F? -- proto shouldn't be valid?
			// could rename target y to x in this case? relies on "globally" (across subprotos) unique vars -- cf. rolename substitution
}

// Not aux
global protocol Proto2(role A, role B) @(y=4);
{
	1() from A to B; @(y>2);	
	do Proto1(A, B); @(y);
}
//*/

/*
global protocol Proto1(role A, role B)
{
	do Proto2(A, B); @1;  
			// FIXME: in this case, consider subsituting the x in Proto1<x+1> like DbC? but would be inconsistent generally?
			// FIXME: at least consider case for substituting x if syntactically just "x" and still just x -- cf. bad.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08b
}

global protocol Proto2(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));

	//do Proto1(A, B); @1;
	do Proto2(A, B); @(x+1);  
			// Unsat -- cf. DbC? -- OK there? but relies on two-unfolding cut off? 
			// No: DbC subs the x in X<x+1> fixing it to two at two unfoldings and forever after? that's why safe there
			
	// FIXME: check tests for "loop counting", e.g., X<x+1> -- and also with lower bounded ints (do bounds manually)
}
//*/

/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	

	//do Proto1(A, B); @x;  // Currently unsat -- cf. DbC? -- DbC it wouldn't be "x", it would "already" be 3 from substitution
			// Note, Proto1 could be called from "any context", so x can really be anything
			// FIXME: make sat? treat single var formula as special case? cf. equality in "non-local" assertions vs. gt/lt

	//do Proto1(A, B); @(x+1);  // Unsat
	do Proto1(A, B); @(x-1);  // Unsat -- should be unsat
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2(x:int) from B to A;  // FIXME: need proper var shadowing
}
//*/
















// ---


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // OK: B knows x

	//---

	1(x:int) from A to B; @(x>3);
	2() from B to C;
	3(y:int) from C to B; @(y>x);  // Bad: C doesn't know x -- though it knows x > 3 -- FIXME: how to disallow this? but still allow the below
			// CHECKME: DbC -- cf. HS
	
	//---	
	
	1(x:int) from A to B; @(x=3);  // FIXME: but equality should be strong enough?
	2() from B to C;
	3(y:int) from C to B; @(y>x);
}
//*/


/*
global protocol Proto1(role A, role B) @(z=0);
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // C does *not* "know" x -- but knows constraints must be satisfied up to here
	3(z:int) from C to D; @(z>y);
	
//--- vs.

	1(x:int) from A to B; @(x=3);  // equality is "precise" enough for "strong path inference"
	2(y:int) from B to C; @(y>x);
	3(z:int) from C to D; @(z>y);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>1);
	2(y:int) from B to C; @(y>x);

	//3(z:int) from C to A; @(z=y);  // OK
	3(z:int) from C to A; @((z=y)&&(y>x));  //  Morally same as above -- given C should know this from the "path" here
			// FIXME? C doesn't know x -- but could pass prev assertions along with current? cf. DbC projection (at receiver)
			// DbC projection vs. HS/TS? -- DbC receive-exists projection vs HS/TS "forall"?
}
//*/



















/*
global protocol Proto1(role A, role B, role C)
{
	// testing "passing" rename (shadow) map with messages -- also need to test re-receiving rename map with already applied renaming

	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // compacting doesn't terminate -- FIXME: F renaming needs to be done based on K? i.e., also rename x in F(C)?
	//3(z:int) from C to D; @(z>x);  // ... FIXME: but what if C uses x again in upcoming assertions after the renaming? -- hence pass the renaming as a message
			// -- keep a ("one-level"?) rename map? -- cf. rec unfolding with rec-annotation substitution
			// -- no: C can't use x as a sender, not known; but how about as receiver?
			// -- should renamed vars be recorded in K?
	//3(z:int) from B to C; @(z>x);
	do Proto1(A, B, C);
}
//*/




























































// --- ???


/*
global protocol JavaSmtBug(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
	do JavaSmtBug(B, S); @x;  // Cf. AssrtExistsFormula::toJavaSmtFormula comments
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}	

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));
		
		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/

